#!/bin/bash

# Architecture-focused directory summarizer for condensed AI context

DIR="${1:-.}"

# Function to generate a comprehensive Claude prompt when Gemini quota is exceeded
generate_claude_fallback_prompt() {
    local target_dir="."
    local max_lines_per_file=100
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "CLAUDE CODE FALLBACK PROMPT"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "ðŸ“‹ Instructions:"
    echo "1. Copy everything below the dashed line"
    echo "2. Open a new Claude Code session (claude.ai/code)"
    echo "3. Paste the entire prompt"
    echo "4. Claude will analyze your codebase and create the summary"
    echo ""
    echo "-------------------------------------------------------------------"
    echo ""
    echo "Please analyze the following codebase and create a comprehensive ARCHITECTURE & TECHNICAL SPECIFICATION document. This should be structured exactly like the prompt below requests."
    echo ""
    echo "## DIRECTORY STRUCTURE"
    echo '```'
    
    # Generate directory tree (limit depth to avoid huge outputs)
    if command -v tree >/dev/null 2>&1; then
        tree -L 4 -I 'node_modules|.git|dist|build|coverage|.next|.cache|*.log|tmp|temp|.env*|vendor|__pycache__|venv|.venv' "$target_dir" 2>/dev/null || find "$target_dir" -type f -name "*.md" -o -name "*.json" -o -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.go" -o -name "*.rs" | grep -v node_modules | sort
    else
        find "$target_dir" -type f -name "*.md" -o -name "*.json" -o -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.go" -o -name "*.rs" | grep -v node_modules | head -50 | sort
    fi
    
    echo '```'
    echo ""
    echo "## KEY FILES CONTENT"
    echo ""
    
    # Include README if exists
    for readme in README.md readme.md README.MD README Readme.md; do
        if [ -f "$target_dir/$readme" ]; then
            echo "### $readme"
            echo '```markdown'
            head -$max_lines_per_file "$target_dir/$readme" 2>/dev/null
            local total_lines=$(wc -l < "$target_dir/$readme" 2>/dev/null || echo 0)
            if [ "$total_lines" -gt "$max_lines_per_file" ]; then
                echo "... (truncated, $((total_lines - max_lines_per_file)) more lines)"
            fi
            echo '```'
            echo ""
            break
        fi
    done
    
    # Include package.json if exists
    if [ -f "$target_dir/package.json" ]; then
        echo "### package.json"
        echo '```json'
        cat "$target_dir/package.json" 2>/dev/null | head -$max_lines_per_file
        echo '```'
        echo ""
    fi
    
    # Include main configuration files
    for config in .gitignore Dockerfile docker-compose.yml Makefile tsconfig.json webpack.config.js vite.config.js next.config.js; do
        if [ -f "$target_dir/$config" ]; then
            echo "### $config"
            echo '```'
            head -30 "$target_dir/$config" 2>/dev/null
            echo '```'
            echo ""
        fi
    done
    
    # Sample source files
    echo "### Sample Source Files"
    echo ""
    
    # Find and show a few key source files
    local file_count=0
    for pattern in "index.js" "main.js" "app.js" "index.ts" "main.ts" "app.ts" "main.py" "app.py" "__init__.py" "main.go" "lib.rs" "main.rs"; do
        while IFS= read -r file; do
            if [ $file_count -lt 3 ]; then
                echo "#### $file"
                echo '```'
                head -50 "$file" 2>/dev/null
                local total_lines=$(wc -l < "$file" 2>/dev/null || echo 0)
                if [ "$total_lines" -gt 50 ]; then
                    echo "... (truncated, $((total_lines - 50)) more lines)"
                fi
                echo '```'
                echo ""
                ((file_count++))
            fi
        done < <(find "$target_dir" -name "$pattern" -type f 2>/dev/null | grep -v node_modules | head -1)
    done
    
    echo ""
    echo "## TASK"
    echo ""
    echo "Based on the codebase structure and files shown above, please create a comprehensive ARCHITECTURE & TECHNICAL SPECIFICATION document that includes:"
    echo ""
    cat << 'CLAUDE_PROMPT_EOF'
# PROJECT OVERVIEW
- Project name and purpose
- What problem it solves
- Target users/audience
- Current development status
- Key features and capabilities

# SETUP & GETTING STARTED
- Prerequisites (Node version, dependencies, etc.)
- Installation steps
- Environment variables needed
- How to run in development
- How to build for production
- Common troubleshooting

# ARCHITECTURE OVERVIEW
- High-level architecture (frontend/backend/database)
- Technology choices and why
- Design patterns used
- Data flow overview
- State management approach
- Authentication/authorization architecture

# PROJECT STRUCTURE
Explain the directory organization and purpose of each major directory.

# KEY MODULES & COMPONENTS
For each major module/directory:
- Purpose and responsibility
- Key files and their roles
- Interfaces/APIs it exposes
- Dependencies and interactions
- Code patterns used

# DATABASE & DATA MODELS
- Database schema overview
- Key tables/collections and relationships
- Migration approach
- Data access patterns

# API DESIGN
- API structure (REST/GraphQL/tRPC)
- Authentication approach
- Endpoint naming conventions
- Request/response formats
- Error handling patterns

# FRONTEND ARCHITECTURE
- Component hierarchy
- Routing structure
- State management details
- Data fetching patterns
- UI component library
- Styling approach

# BUSINESS LOGIC
- Where business rules live
- How features are implemented
- Service layer patterns
- Data validation approach
- Error handling strategy

# TESTING STRATEGY
- Test file locations
- Testing frameworks used
- What to test and how
- Running tests

# DEPLOYMENT & CONFIGURATION
- Build process
- Deployment targets
- Environment-specific configs
- CI/CD pipeline

# DEVELOPMENT WORKFLOW
- Git branch strategy
- Code review process
- Coding standards
- Important scripts
- Debugging tips

# SECURITY CONSIDERATIONS
- Authentication implementation
- Authorization checks
- Data validation
- API security
- Secrets management

# PERFORMANCE OPTIMIZATIONS
- Caching strategies
- Database query optimization
- Frontend optimizations
- Bundle size management

# IMPORTANT PATTERNS & CONVENTIONS
- Naming conventions
- File organization rules
- Code style guidelines
- Common utilities to use
- Patterns to follow/avoid

# CURRENT LIMITATIONS & TECH DEBT
- Known issues
- Areas needing refactoring
- Performance bottlenecks
- Missing features

# ADDING NEW FEATURES
Step-by-step guide for common development tasks.

Please make this document comprehensive (aim for 10,000+ words), include specific code examples from the project, and be as detailed as possible. Format it as markdown.
CLAUDE_PROMPT_EOF
    
    echo ""
    echo "-------------------------------------------------------------------"
    echo ""
    echo "âœ… Prompt generated! Copy everything above and paste into Claude Code."
    echo ""
}

# Change to target directory so Gemini analyzes the right location
cd "$DIR" || exit 1

# Create a temporary file to capture Gemini output and errors
TEMP_OUTPUT=$(mktemp)
TEMP_ERROR=$(mktemp)

# Function to clean up temp files
cleanup() {
    rm -f "$TEMP_OUTPUT" "$TEMP_ERROR"
}
trap cleanup EXIT

# Run gemini with architecture-focused prompt and capture both stdout and stderr
gemini --yolo > "$TEMP_OUTPUT" 2> "$TEMP_ERROR" << 'EOF'
You are a senior software engineer, architect, and tech lead. 
- You are an expert in the field of software engineering and architecture. 
- You are also a great communicator and writer. You are able to write in a way that is easy to understand and follow.
- You are also able to write in a way that is concise and to the point. 
- You are also able to write in a way that is engaging and interesting to read. 
- You are also able to write in a way that is accurate and correct. 
- You are also able to write in a way that is helpful and useful to the reader. 
- You are also able to write in a way that is easy to understand and follow.

Your task is to create a comprehensive ARCHITECTURE & TECHNICAL SPECIFICATION document for this codebase. This will be used as condensed context for AI agents to understand how to work with this project.

IMPORTANT: 
- Focus on architecture, not file listings
- Respect .gitignore - skip node_modules, build outputs, etc.
- Think like a senior engineer onboarding someone new
- Include actual code examples for key patterns

Structure the document as follows:

# PROJECT OVERVIEW
- Project name and purpose
- What problem it solves
- Target users/audience
- Current development status
- Key features and capabilities

# SETUP & GETTING STARTED
- Prerequisites (Node version, dependencies, etc.)
- Installation steps from README
- Environment variables needed
- How to run in development
- How to build for production
- Common troubleshooting

# ARCHITECTURE OVERVIEW
- High-level architecture (frontend/backend/database/tooling/setup/etc..)
- Technology choices and why
- Design patterns used
- Data flow overview
- State management approach
- Authentication/authorization architecture

# PROJECT STRUCTURE
Explain the directory organization:
```
src/
â”œâ”€â”€ components/     # [Explain what goes here]
â”œâ”€â”€ pages/         # [Explain routing approach]
â”œâ”€â”€ lib/           # [Explain utilities]
â””â”€â”€ ...
```

# KEY MODULES & COMPONENTS

For each major module/directory:
## Module Name
- Purpose and responsibility
- Key files and their roles
- Interfaces/APIs it exposes
- Dependencies and interactions
- Code patterns used

Include actual code snippets showing typical patterns:
```typescript
// Example component structure
// Example API endpoint
// Example utility function
```

# DATABASE & DATA MODELS
- Database schema overview
- Key tables/collections and relationships
- Migration approach
- Data access patterns
- Example queries

# API DESIGN
- API structure (REST/GraphQL/tRPC)
- Authentication approach
- Endpoint naming conventions
- Request/response formats
- Error handling patterns
- Example API calls

# FRONTEND ARCHITECTURE
- Component hierarchy
- Routing structure
- State management details
- Data fetching patterns
- UI component library
- Styling approach (CSS/Tailwind/etc)
- Form handling
- Client-side validation

# BUSINESS LOGIC
- Where business rules live
- How features are implemented
- Service layer patterns
- Data validation approach
- Error handling strategy

# TESTING STRATEGY
- Test file locations
- Testing frameworks used
- What to test and how
- Running tests
- Test data approach

# DEPLOYMENT & CONFIGURATION
- Build process
- Deployment targets
- Environment-specific configs
- CI/CD pipeline
- Monitoring approach

# DEVELOPMENT WORKFLOW
- Git branch strategy
- Code review process
- Coding standards
- Important scripts in package.json
- Debugging tips

# SECURITY CONSIDERATIONS
- Authentication implementation
- Authorization checks
- Data validation
- API security
- Secrets management

# PERFORMANCE OPTIMIZATIONS
- Caching strategies
- Database query optimization
- Frontend optimizations
- Bundle size management

# IMPORTANT PATTERNS & CONVENTIONS
- Naming conventions
- File organization rules
- Code style guidelines
- Common utilities to use
- Patterns to follow/avoid

# CURRENT LIMITATIONS & TECH DEBT
- Known issues
- Areas needing refactoring
- Performance bottlenecks
- Missing features

# INTEGRATION POINTS
- External services used
- API integrations
- Webhook handlers
- Third-party libraries

# ADDING NEW FEATURES
Step-by-step guide:
1. Where to add new routes
2. How to create new components
3. Database migration process
4. API endpoint creation
5. Testing requirements

Include code templates for common tasks.

Now use the summarize_directory tool to create this architecture-focused technical specification. Make sure to:
1. Set the outputFile parameter to "DIRECTORY_SUMMARY.md" (not ARCHITECTURE.md)
2. Create an EXTREMELY detailed document - aim for 10,000+ words
3. Include actual code examples from the project
4. Be exhaustive in documenting every aspect
EOF

# Capture exit code
GEMINI_EXIT_CODE=$?

# Check for common error patterns in stderr AND stdout
ERROR_CONTENT=""
if [ -s "$TEMP_ERROR" ]; then
    ERROR_CONTENT=$(cat "$TEMP_ERROR")
fi

# Also check stdout for error patterns (sometimes errors go to stdout)
if [ -s "$TEMP_OUTPUT" ]; then
    OUTPUT_CONTENT=$(cat "$TEMP_OUTPUT")
    ERROR_CONTENT="$ERROR_CONTENT$OUTPUT_CONTENT"
fi

# Check for specific error patterns in the content
if [ -n "$ERROR_CONTENT" ]; then
    # Check for quota exceeded error
    if echo "$ERROR_CONTENT" | grep -qi "quota exceeded\|resource_exhausted\|rateLimitExceeded"; then
        echo "âŒ ERROR: Gemini API quota exceeded"
        echo ""
        echo "Your Gemini API quota has been reached for today. This usually means:"
        echo "â€¢ You've hit the daily request limit for Gemini 2.5 Pro"
        echo "â€¢ The quota typically resets at midnight Pacific Time"
        echo ""
        
        # Offer Claude Code as fallback
        echo "ðŸ¤– Would you like to use Claude Code as a fallback? (y/n)"
        echo "   Claude can analyze your codebase without using Gemini's API quota."
        echo ""
        
        # Check if we're in an interactive terminal
        if [ -t 0 ]; then
            read -r -p "Proceed with Claude Code? [y/N] " response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                echo ""
                echo "ðŸš€ Generating Claude Code prompt..."
                echo ""
                
                # Generate comprehensive context for Claude
                generate_claude_fallback_prompt
                exit 0
            fi
        fi
        
        echo ""
        echo "Other solutions:"
        echo "1. Wait until tomorrow for quota reset"
        echo "2. Check your Google Cloud Console for quota status:"
        echo "   https://console.cloud.google.com/apis/api/generativelanguage.googleapis.com"
        echo "3. Consider upgrading your API plan if you need higher limits"
        echo ""
        echo "For more details on Gemini API quotas, see:"
        echo "https://ai.google.dev/gemini-api/docs/rate-limits"
        exit 1
    
    # Check for authentication errors
    elif echo "$ERROR_CONTENT" | grep -qi "authentication\|unauthorized\|permission denied"; then
        echo "âŒ ERROR: Gemini API authentication failed"
        echo ""
        echo "Please check your Gemini API setup:"
        echo "1. Ensure you have a valid API key configured"
        echo "2. Check that the Gemini CLI is properly installed"
        echo "3. Verify your API key has the necessary permissions"
        echo ""
        
        # Offer Claude Code as fallback for auth errors too
        if [ -t 0 ]; then
            echo "ðŸ¤– Would you like to use Claude Code instead? (y/n)"
            read -r -p "Proceed with Claude Code? [y/N] " response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                echo ""
                echo "ðŸš€ Generating Claude Code prompt..."
                echo ""
                generate_claude_fallback_prompt
                exit 0
            fi
        fi
        
        echo ""
        echo "For setup instructions, see:"
        echo "https://github.com/google/generative-ai-docs/tree/main/gemini-cli"
        exit 1
    
    # Check for network errors
    elif echo "$ERROR_CONTENT" | grep -qi "network\|connection\|timeout"; then
        echo "âŒ ERROR: Network connection failed"
        echo ""
        echo "Unable to connect to Gemini API. Please check:"
        echo "1. Your internet connection"
        echo "2. Firewall settings"
        echo "3. Google Cloud service status"
        echo ""
        echo "Error details:"
        echo "$ERROR_CONTENT" | head -3
        exit 1
    
    # Check for other actual error patterns
    elif echo "$ERROR_CONTENT" | grep -qi "error\|failed\|exception\|gaxioserror\|attempt.*failed"; then
        echo "âŒ ERROR: Gemini API request failed"
        echo ""
        echo "Error details:"
        echo "$ERROR_CONTENT" | head -5
        echo ""
        echo "If this persists, try:"
        echo "1. Checking your API key and permissions"
        echo "2. Verifying Gemini CLI installation: gemini --version"
        echo "3. Testing a simple Gemini request manually"
        exit 1
    fi
    # If no error patterns are found, continue (stderr might just be informational)
fi

# Check if gemini command failed
if [ $GEMINI_EXIT_CODE -ne 0 ]; then
    echo "âŒ ERROR: Gemini command failed with exit code $GEMINI_EXIT_CODE"
    
    if [ -s "$TEMP_ERROR" ]; then
        echo ""
        echo "Error output:"
        cat "$TEMP_ERROR"
    fi
    
    exit $GEMINI_EXIT_CODE
fi

# Check if the expected DIRECTORY_SUMMARY.md file was created (normal case)
if [ -f "DIRECTORY_SUMMARY.md" ]; then
    # Success - the MCP tool created the file as expected
    exit 0
fi

# If no file was created, check if we have stdout output (fallback case)
if [ -s "$TEMP_OUTPUT" ]; then
    # Check if the output contains error patterns (sometimes Gemini outputs errors to stdout)
    OUTPUT_CONTENT=$(cat "$TEMP_OUTPUT")
    if echo "$OUTPUT_CONTENT" | grep -qi "quota exceeded\|resource_exhausted\|rateLimitExceeded\|gaxioserror\|attempt.*failed"; then
        echo "âŒ ERROR: Gemini API request failed (detected error in output)"
        echo ""
        echo "The output contains error information instead of a valid summary."
        echo "This usually indicates API quota or authentication issues."
        echo ""
        echo "First few lines of error output:"
        echo "$OUTPUT_CONTENT" | head -5
        exit 1
    fi
    
    # Output the result to stdout (fallback for direct output mode)
    cat "$TEMP_OUTPUT"
    exit 0
fi

# Neither file nor output was generated
echo "âŒ ERROR: No summary was generated"
echo ""
echo "Neither DIRECTORY_SUMMARY.md file nor stdout output was created."
echo "This could indicate:"
echo "1. API quota issues"
echo "2. Authentication problems"
echo "3. Network connectivity issues"

if [ -s "$TEMP_ERROR" ]; then
    echo ""
    echo "Error details:"
    cat "$TEMP_ERROR"
fi

exit 1